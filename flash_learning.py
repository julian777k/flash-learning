
# flash_learning.py (집중형 플래시카드 실행 스크립트)  # (모듈 헤더 + 파일 설명 + 실행 진입점 안내)
# 사용: python flash_learning.py --domain mysql --level 1 --mode r1 --start 0 --page 30 [--seed 42] [--progress]  # (주석 + 사용예 + 선택 옵션 설명)

import json  # (import 문 + 모듈 불러오기 + json 파일을 읽기 위해)
import os  # (import 문 + 운영체제 경로 + 파일 경로 결합을 위해)
import random  # (import 문 + 난수 생성 + r2/r3 무작위 선정을 위해)
import argparse  # (import 문 + 명령행 인자 파싱 + CLI 실행을 위해)
import time  # (import 문 + 시간 제어 + 명상 타이머/프로그레스 표시를 위해)

DATA_DIR = os.path.dirname(__file__)  # (상수 선언 + 현재 스크립트 폴더 + 데이터 파일 상대경로 사용)
PAGE_DEFAULT = 30  # (상수 선언 + 기본 카드 수 + r1/r2/r3에서 30장 규칙 적용)
REST_SEC = 120  # (상수 선언 + 명상 휴식 2분 + 루프 사이 타이머 기본값)

def load_level_file(domain: str, level: int):  # (함수 정의 + 타입힌트 + 도메인/레벨 파일 읽기용)
    """도메인/레벨 JSON 로드 (예: mysql_L1.json)"""  # (docstring + 함수 설명 + 사용 이유)
    fname = f"{domain}_L{level}.json"  # (포맷 문자열 + 파일명 구성 + 규칙적 네이밍)
    path = os.path.join(DATA_DIR, fname)  # (경로 결합 + OS 독립성 + 안전한 파일 접근)
    with open(path, 'r', encoding='utf-8') as f:  # (with 문 + 컨텍스트 관리 + 파일 자동 닫힘)
        return json.load(f)  # (반환문 + JSON 디코드 결과 + 카드 리스트 반환)

def pick_round1(cards, start: int = 0, page: int = PAGE_DEFAULT):  # (함수 정의 + r1 순차 선택 + 페이지 개념)
    """order_index 순서로 정렬 후 start*page ~ start*page+page-1 범위 30장 선택"""  # (docstring + 동작 설명)
    ordered = sorted(cards, key=lambda c: c.get('order_index', 10**9))  # (정렬 + 키 함수 + 누락시 큰 값 처리)
    s = start * page  # (계산 + 시작 인덱스 + 페이지 오프셋)
    e = s + page  # (계산 + 끝 인덱스 + 슬라이스 범위 상한)
    return ordered[s:e]  # (반환문 + 슬라이싱 결과 + 30장 반환)

def pick_round2(cards, page: int = PAGE_DEFAULT, seed: int | None = None):  # (함수 정의 + r2 랜덤 선택 + 시드 옵션)
    """전체 풀에서 중복 없이 무작위 30장"""  # (docstring + 동작 설명)
    rng = random.Random(seed)  # (객체 생성 + 독립 난수기 + 재현성 제어)
    return rng.sample(cards, k=min(page, len(cards)))  # (표본추출 + 개수 보호 + 카드 수 부족 대비)

def pick_round3(cards, prev_ids: set, page: int = PAGE_DEFAULT, seed: int | None = None):  # (함수 정의 + r3 혼합 + 중복 회피)
    """core 10, applied 10, 나머지 10 (이전 회차 중복 회피)"""  # (docstring + 동작 설명)
    rng = random.Random(seed)  # (난수기 생성 + 시드 재현성 + 선택 일관성)
    pool = [c for c in cards if c.get('keyword') not in prev_ids]  # (리스트 내포 + 중복 제거 + 키워드 기준)
    core = [c for c in pool if 'core' in c.get('tags', [])]  # (필터 + 핵심 태그 + 코어 그룹)
    applied = [c for c in pool if 'applied' in c.get('tags', [])]  # (필터 + 응용 태그 + 어플라이드 그룹)
    others = [c for c in pool if 'core' not in c.get('tags', []) and 'applied' not in c.get('tags', [])]  # (필터 + 기타 태그 + 보충군)
    take_core = rng.sample(core, k=min(10, len(core)))  # (표본추출 + 코어 10장 + 부족 대비)
    take_applied = rng.sample(applied, k=min(10, len(applied)))  # (표본추출 + 응용 10장 + 부족 대비)
    remaining = PAGE_DEFAULT - len(take_core) - len(take_applied)  # (계산 + 남은 수량 + 총합 30 유도)
    take_others = rng.sample(others if len(others) >= remaining else pool, k=min(remaining, len(pool)))  # (표본추출 + 유연한 보충 + 안전성)
    picked = take_core + take_applied + take_others  # (리스트 결합 + 최종 묶기 + 순서 유지)
    rng.shuffle(picked)  # (무작위 섞기 + 학습 편향 방지 + 집중 유지)
    return picked  # (반환문 + 최종 30장 + 완료)

def show_cards(cards, progress: bool = False):  # (함수 정의 + 출력 함수 + 진행바 옵션)
    """키워드/의미/한 줄 사용을 한눈형으로 출력"""  # (docstring + UI 목표 + 단순성)
    total = len(cards)  # (변수 할당 + 총 카드 수 + 진행률 계산용)
    for i, c in enumerate(cards, 1):  # (반복문 + 1부터 인덱스 + 사용자 친화)
        print(f"\n[{i}/{total}] {c['keyword']}")  # (출력 + 현재 위치 + 키워드 강조)
        print(f"- 의미: {c['meaning']}")  # (출력 + 의미 + 한 줄 원칙)
        print(f"- 예시: {c['usage_one_liner']}")  # (출력 + 사용 예시 + 복사 실행 가능)
        if progress:  # (조건문 + 진행바 표시 여부 + 토글)
            bar_len = 20  # (상수 유사 + 막대 길이 + 시각 가독성)
            filled = int(bar_len * i / max(1,total))  # (계산 + 채워진 블록 수 + 0분모 방지)
            bar = '█'*filled + '-'*(bar_len-filled)  # (문자 연산 + 막대 구성 + 가독성)
            print(f"진행: |{bar}| {int(100*i/max(1,total))}%")  # (출력 + 진행률 퍼센트 + 사용자 피드백)

def meditate(seconds: int = REST_SEC):  # (함수 정의 + 명상 타이머 + 기본 120초)
    """간단 명상 타이머 (2분 기본)"""  # (docstring + 휴식 유도 + 기억 고착)
    for s in range(seconds, 0, -1):  # (반복문 + 카운트다운 + 사용자 안내)
        if s % 10 == 0 or s <= 5:  # (조건문 + 10초 간격/마지막 5초 + 과도한 갱신 방지)
            print(f"휴식 남은 시간: {s}초")  # (출력 + 남은 시간 + 동기 부여)
        time.sleep(1)  # (대기 + 1초 슬립 + 실시간 카운트)

def main():  # (메인 함수 정의 + 엔트리 포인트 + CLI 실행)
    parser = argparse.ArgumentParser(description="Flash Learning: r1/r2/r3")  # (객체 생성 + 인자 파서 + 설명)
    parser.add_argument('--domain', required=True, choices=['python','pandas','mysql'])  # (옵션 정의 + 필수 + 값 제한)
    parser.add_argument('--level', type=int, required=True)  # (옵션 정의 + 정수형 + 레벨 선택)
    parser.add_argument('--mode', required=True, choices=['r1','r2','r3'])  # (옵션 정의 + 라운드 선택 + r1/r2/r3)
    parser.add_argument('--start', type=int, default=0)  # (옵션 정의 + r1 전용 시작 페이지 + 기본 0)
    parser.add_argument('--page', type=int, default=PAGE_DEFAULT)  # (옵션 정의 + 한 번에 뽑을 카드 수 + 기본 30)
    parser.add_argument('--seed', type=int, default=None)  # (옵션 정의 + r2/r3 재현성 시드 + 선택)
    parser.add_argument('--progress', action='store_true')  # (옵션 정의 + 진행바 토글 + 기본 꺼짐)
    parser.add_argument('--rest', type=int, default=REST_SEC)  # (옵션 정의 + 휴식 시간 조정 + 실험용)
    args = parser.parse_args()  # (파싱 호출 + 사용자 입력 해석 + 네임스페이스 획득)
py -3.13 -m pip install pyttsx3

    cards = load_level_file(args.domain, args.level)  # (함수 호출 + 카드 로드 + 도메인/레벨별)
    picked = []  # (변수 초기화 + 선택 결과 담을 리스트 + 이후 분기에서 채움)
    if args.mode == 'r1':  # (조건문 + r1 분기 + 순차)
        picked = pick_round1(cards, start=args.start, page=args.page)  # (호출 + 인자 전달 + 30장 페이지)
    elif args.mode == 'r2':  # (조건문 + r2 분기 + 랜덤)
        picked = pick_round2(cards, page=args.page, seed=args.seed)  # (호출 + 시드 전달 + 재현 가능)
    else:  # (else 분기 + r3 혼합 + 중복 회피 기반)
        # r3는 시연 편의상 동일 레벨 카드에서 중복만 회피  # (주석 + 설계 설명 + 단순 전략)
        prev = set()  # (집합 생성 + 이전 키워드 모음 + 초기에는 빈 집합)
        picked = pick_round3(cards, prev_ids=prev, page=args.page, seed=args.seed)  # (호출 + 혼합 로직 + 결과)
    show_cards(picked, progress=args.progress)  # (UI 출력 + 진행바 선택적 표시 + 한눈형)

if __name__ == '__main__':  # (진입점 가드 + 모듈/스크립트 구분 + 직접 실행시만 동작)
    main()  # (함수 호출 + 프로그램 시작 + 종료시 자연 반환)
